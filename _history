{"entries":[{"timestamp":1765304834670,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":3849,"diffs":[[1,""]]},{"start1":1,"length1":55,"diffs":[[1,""]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":0,"length1":20,"diffs":[[1,""]]},{"start1":1,"length1":3441,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":134,"length1":123,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":279,"length1":41,"diffs":[[1,"    \"languageRestriction\": \"python-only\",\n    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1765306695385,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":45,"length1":63,"diffs":[[1,""]]},{"start1":197,"length1":172,"diffs":[[1,"        \n"]]},{"start1":243,"length1":115,"diffs":[[1,"        finch.setBeak(0, 0, 0)\n"]]},{"start1":1306,"length1":31,"diffs":[[1,""]]},{"start1":1463,"length1":0,"diffs":[[1,"            finch.stopMotors()\n"]]},{"start1":1879,"length1":37,"diffs":[[1,""]]},{"start1":1945,"length1":0,"diffs":[[1,"                finch.setBeak(0, 0, 100)\n"]]},{"start1":2026,"length1":113,"diffs":[[1,"                finch.setMove(MoveDir.Forward, y - 31, 50)\n"]]},{"start1":2155,"length1":0,"diffs":[[1,"                finch.setBeak(0, 0, 100)\n"]]},{"start1":2319,"length1":50,"diffs":[[1,""]]},{"start1":2352,"length1":0,"diffs":[[1,"                finch.setBeak(0, 0, 100)\n"]]},{"start1":2478,"length1":50,"diffs":[[1,""]]},{"start1":2548,"length1":0,"diffs":[[1,"                finch.setBeak(0, 0, 100)\n"]]},{"start1":2641,"length1":52,"diffs":[[1,""]]},{"start1":2705,"length1":157,"diffs":[[1,""]]},{"start1":2759,"length1":313,"diffs":[[1,"                this.dance()\n                break\n"]]},{"start1":2948,"length1":97,"diffs":[[1,""]]},{"start1":3107,"length1":33,"diffs":[[1,""]]},{"start1":3341,"length1":91,"diffs":[[1,"            finch.setTurn(RLDir.Right, 45, 75)\n            finch.setTurn(RLDir.Left, 45, 75)\n"]]},{"start1":3827,"length1":1070,"diffs":[[1,"        \n"]]},{"start1":3850,"length1":50,"diffs":[[1,""]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":173,"length1":0,"diffs":[[1,"    \n"]]},{"start1":202,"length1":294,"diffs":[[1,"        pass\n    \n    \n    def selectMode(self):\n        finch.set_beak(0, 0, 0)\n"]]},{"start1":663,"length1":0,"diffs":[[1,"\n"]]},{"start1":1227,"length1":32,"diffs":[[1,""]]},{"start1":1361,"length1":0,"diffs":[[1,"            finch.stop_motors()\n"]]},{"start1":1700,"length1":38,"diffs":[[1,""]]},{"start1":1763,"length1":0,"diffs":[[1,"                finch.set_beak(0, 0, 100)\n"]]},{"start1":1846,"length1":103,"diffs":[[1,"                finch.set_move(MoveDir.FORWARD,y-31,50)\n"]]},{"start1":1964,"length1":0,"diffs":[[1,"                finch.set_beak(0, 0, 100)\n"]]},{"start1":2129,"length1":45,"diffs":[[1,""]]},{"start1":2154,"length1":0,"diffs":[[1,"                finch.set_beak(0, 0, 100)\n"]]},{"start1":2281,"length1":45,"diffs":[[1,""]]},{"start1":2343,"length1":0,"diffs":[[1,"                finch.set_beak(0, 0, 100)\n"]]},{"start1":2438,"length1":47,"diffs":[[1,""]]},{"start1":2475,"length1":150,"diffs":[[1,""]]},{"start1":2526,"length1":632,"diffs":[[1,"                self.dance()\n                break\n    def dance(self):\n"]]},{"start1":2743,"length1":33,"diffs":[[1,"            r \n"]]},{"start1":2997,"length1":93,"diffs":[[1,"            finch.set_turn(RLDir.RIGHT, 45, 75)\n            finch.set_turn(RLDir.LEFT, 45, 75)\n"]]},{"start1":3328,"length1":1005,"diffs":[[1,"            finch.set_beak(100, 0, 0)\n    def returnHome(self):\n        pass\n        \n"]]},{"start1":3461,"length1":0,"diffs":[[1,"\n"]]}]}]},{"timestamp":1765314465178,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":2818,"length1":32,"diffs":[[1,"            # print(self.xValues)\n"]]}]}]},{"timestamp":1765376458581,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3179,"length1":38,"diffs":[[1,"            //  print(self.xValues)\n"]]}]}]},{"timestamp":1765376459037,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3179,"length1":36,"diffs":[[1,"            console.log(this.xValues)\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":2818,"length1":34,"diffs":[[1,"            print(self.xValues)\n"]]}]}]},{"timestamp":1765376547145,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":3747,"length1":13,"diffs":[[1,""]]}]}]},{"timestamp":1765382898835,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":3747,"length1":18,"diffs":[[1,"            \n"]]}]}]},{"timestamp":1765382902022,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3340,"length1":166,"diffs":[[1,"                input.onButtonPressed(Button.A, function on_button_pressed_a() {\n                    this.resultsExplore\n                })\n"]]},{"start1":3666,"length1":483,"diffs":[[1,""]]},{"start1":4279,"length1":48,"diffs":[[1,""]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":2973,"length1":160,"diffs":[[1,"                def on_button_pressed_a():\n                    self.resultsExplore\n                input.on_button_pressed(Button.A, on_button_pressed_a)\n"]]},{"start1":3279,"length1":415,"diffs":[[1,"    def resultsExplore(self):\n        for item in self.xValues:\n            print(f\"made a movement or rotation of {self.xValues[item]}cm/degrees on turn {self.moveNumber[item]}\")\n"]]},{"start1":3747,"length1":0,"diffs":[[1,"            finch\n"]]},{"start1":4004,"length1":49,"diffs":[[1,""]]}]}]},{"timestamp":1765383501652,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1730,"length1":100,"diffs":[[1,""]]},{"start1":2189,"length1":137,"diffs":[[1,"            finch.setBeak(0, 0, 100)\n            x = randint(1, 5)\n"]]},{"start1":3305,"length1":26,"diffs":[[1,""]]},{"start1":4128,"length1":344,"diffs":[[1,""]]},{"start1":4950,"length1":31,"diffs":[[1,"            if (count == 30) {\n"]]},{"start1":5283,"length1":219,"diffs":[[1,""]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":21,"length1":0,"diffs":[[1,"\n"]]},{"start1":1499,"length1":118,"diffs":[[1,"    def checkDistance(self):\n"]]},{"start1":1907,"length1":356,"diffs":[[1,"            finch.set_beak(0, 0, 100)\n            x = randint(1, 5)\n            if x == 1 or x == 5:\n                y = finch.get_distance()\n                finch.set_move(MoveDir.FORWARD,y-30,50)\n                self.yValues.append(int(y-30))\n                self.checkDistance()\n"]]},{"start1":2937,"length1":26,"diffs":[[1,""]]},{"start1":3680,"length1":210,"diffs":[[1,"                pri\n"]]},{"start1":4392,"length1":28,"diffs":[[1,"            if count == 30:\n"]]},{"start1":4605,"length1":220,"diffs":[[1,"            finch.set_beak(100, 0, 0)    \n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":231,"length1":113,"diffs":[[1,"        \"datalogger\": \"*\"\n"]]}]}]},{"timestamp":1765384100276,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1830,"length1":43,"diffs":[[1,"        if (finch.getDistance() < 30) {\n"]]},{"start1":2002,"length1":94,"diffs":[[1,""]]},{"start1":2012,"length1":0,"diffs":[[1,"        \n"]]},{"start1":2412,"length1":922,"diffs":[[1,"            }\n            if (x == 1 || x == 5) {\n                y = finch.getDistance()\n                finch.setMove(MoveDir.Forward, y - 30, 50)\n                this.yValues.push(Math.trunc(y - 30))\n"]]},{"start1":2652,"length1":679,"diffs":[[1,"            } else if (x == 2) {\n                y = randint(10, 90)\n                finch.setTurn(RLDir.Right, y, 50)\n                this.checkDistance()\n                this.yValues.push(Math.trunc(-y))\n            } else if (x == 3) {\n                y = randint(10, 90)\n                finch.setTurn(RLDir.Left, y, 50)\n                this.yValues.push(Math.trunc(-y))\n                this.checkDistance()\n            } else if (x == 4) {\n                finch.setTurn(RLDir.Right, 180, 50)\n                this.yValues.push(Math.trunc(-180))\n                this.checkDistance()\n"]]},{"start1":3251,"length1":0,"diffs":[[1,"            \n            this.xValues.push(Math.trunc(x))\n            this.moveNumber.push(count)\n            //  print(self.xValues)\n            //  print(self.yValues)\n            count += 1\n            if (count == 20) {\n                o = false\n                finch.stopMotors()\n                //  def on_button_pressed_a():\n                //      self.resultsExplore\n                //  input.on_button_pressed(Button.A, on_button_pressed_a)\n                input.onButtonPressed(Button.B, function on_button_pressed_b() {\n                    this.returnHome()\n                })\n            }\n            \n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":1616,"length1":41,"diffs":[[1,"        if finch.get_distance() < 30:\n"]]},{"start1":1786,"length1":74,"diffs":[[1,""]]},{"start1":2351,"length1":603,"diffs":[[1,"            elif x == 2:\n                y = randint(10,90)\n                finch.set_turn(RLDir.RIGHT, y, 50)\n"]]},{"start1":2499,"length1":623,"diffs":[[1,"                self.yValues.append(int(-y))\n            elif x == 3:\n                y = randint(10,90)\n                finch.set_turn(RLDir.LEFT, y, 50)\n                self.yValues.append(int(-y))\n                self.checkDistance()\n            elif x == 4:\n                finch.set_turn(RLDir.RIGHT, 180, 50)\n                self.yValues.append(int(-180))\n                self.checkDistance()\n            self.xValues.append(int(x))\n            self.moveNumber.append(count)\n            # print(self.xValues)\n            # print(self.yValues)\n            count += 1\n            if count == 20:\n                o = False\n                finch.stop_motors()\n                # def on_button_pressed_a():\n                #     self.resultsExplore\n                # input.on_button_pressed(Button.A, on_button_pressed_a)\n                def on_button_pressed_b():\n                    self.returnHome()\n                input.on_button_pressed(Button.B, on_button_pressed_b)\n"]]},{"start1":6194,"length1":18,"diffs":[[1,"robot.selectMode()\n"]]}]}]},{"timestamp":1765384889222,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":6412,"length1":19,"diffs":[[1,"robot.selectMode()"]]}]}]},{"timestamp":1765385531184,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":6412,"length1":18,"diffs":[[1,"robot.selectMode()\n"]]}]}]},{"timestamp":1765385552215,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":6364,"length1":107,"diffs":[[1,"        // This method takes a value from my explores so taht way once its done the finch can return home!\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":5421,"length1":122,"diffs":[[1,"    def returnHome(self):#This method takes a value from my explores so taht way once its done the finch can return home!\n"]]},{"start1":6412,"length1":19,"diffs":[[1,"robot.selectMode()"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":231,"length1":26,"diffs":[[1,"        \"datalogger\": \"*\",\n        \"microbit-pxt-timeanddate\": \"github:bsiever/microbit-pxt-timeanddate#v2.0.33\"\n"]]}]}]},{"timestamp":1765385770233,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":6412,"length1":18,"diffs":[[1,"robot.selectMode()\n"]]}]}]},{"timestamp":1765386323778,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":547,"length1":35,"diffs":[[1,"        finch.setBeak(100, 100, 100)\n"]]},{"start1":959,"length1":73,"diffs":[[1,"        // the driveSquare method aloows our finch to drive in a set path\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":452,"length1":36,"diffs":[[1,"        finch.set_beak(100, 100, 100)\n"]]},{"start1":870,"length1":89,"diffs":[[1,"    def driveSquare(self):#the driveSquare method aloows our finch to drive in a set path\n"]]}]}]},{"timestamp":1765386698636,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2002,"length1":103,"diffs":[[1,""]]},{"start1":7326,"length1":53,"diffs":[[1,""]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":1786,"length1":110,"diffs":[[1,""]]},{"start1":6251,"length1":49,"diffs":[[1,""]]}]}]},{"timestamp":1765387150817,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":6389,"length1":17,"diffs":[[1,"                pass\n"]]}]}]},{"timestamp":1765401646032,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":6389,"length1":20,"diffs":[[1,"                \n"]]}]}]},{"timestamp":1765401646719,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3018,"length1":53,"diffs":[[1,"                    this.yValues.push(Math.trunc(-y))\n"]]},{"start1":3202,"length1":53,"diffs":[[1,"                    this.yValues.push(Math.trunc(-y))\n"]]},{"start1":3390,"length1":55,"diffs":[[1,"                    this.yValues.push(Math.trunc(-180))\n"]]},{"start1":6881,"length1":64,"diffs":[[1,"                finch.setTurn(RLDir.Right, this.yValues[-1], 50)\n"]]},{"start1":7076,"length1":65,"diffs":[[1,"                finch.setTurn(RLDir.Left, this.yValues[-1], 50)\n"]]},{"start1":7465,"length1":146,"diffs":[[1,"                \n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":2699,"length1":48,"diffs":[[1,"                    self.yValues.append(int(-y))\n"]]},{"start1":2870,"length1":48,"diffs":[[1,"                    self.yValues.append(int(-y))\n"]]},{"start1":3046,"length1":50,"diffs":[[1,"                    self.yValues.append(int(-180))\n"]]},{"start1":5898,"length1":65,"diffs":[[1,"                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n"]]},{"start1":6062,"length1":66,"diffs":[[1,"                finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n"]]},{"start1":6389,"length1":123,"diffs":[[1,"                fin\n"]]}]}]},{"timestamp":1765402139822,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":488,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1765462395271,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":488,"length1":14,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1765462398147,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":582,"length1":406,"diffs":[[1,"        input.onButtonPressed(Button.A, function on_button_pressed_a() {\n            this.driveSquare()\n        })\n        input.onButtonPressed(Button.B, function on_button_pressed_b() {\n            this.explore()\n        })\n        input.onButtonPressed(Button.AB, function on_button_pressed_ab() {\n            this.dance()\n        })\n"]]},{"start1":6186,"length1":48,"diffs":[[1,"        }\n        \n        if (finch.getDistance() > 30) {\n            finch.setBeak(0, 100, 0)\n        }\n        \n        if (finch.getDistance() == 47) {\n"]]},{"start1":6405,"length1":84,"diffs":[[1,""]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":488,"length1":436,"diffs":[[1,"        while\n        def on_button_pressed_a():\n            self.driveSquare()\n        input.on_button_pressed(Button.A, on_button_pressed_a)\n        def on_button_pressed_b():\n            self.explore()\n        input.on_button_pressed(Button.B, on_button_pressed_b)\n        def on_button_pressed_ab():\n            self.dance()\n        input.on_button_pressed(Button.AB, on_button_pressed_ab)\n"]]},{"start1":5358,"length1":41,"diffs":[[1,"        if finch.get_distance() > 30:\n            finch.set_beak(0, 100, 0) \n        if finch.get_distance() == 47:\n"]]},{"start1":5539,"length1":78,"diffs":[[1,""]]}]}]},{"timestamp":1765462502108,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":359,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1765463741491,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":359,"length1":10,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1765463742246,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":108,"length1":24,"diffs":[[1,""]]},{"start1":432,"length1":23,"diffs":[[1,""]]},{"start1":2471,"length1":23,"diffs":[[1,"        let count = 0\n"]]},{"start1":3674,"length1":49,"diffs":[[1,"                this.moveNumber.push(count)\n"]]},{"start1":3802,"length1":72,"diffs":[[1,"                count += 1\n                if (count == 20) {\n"]]},{"start1":5353,"length1":23,"diffs":[[1,"        let count = 0\n"]]},{"start1":5918,"length1":64,"diffs":[[1,"            count += 1\n            if (count == 10) {\n"]]},{"start1":6506,"length1":153,"diffs":[[1,"        // This method takes a value from my explores so that way once its done the finch can return home!\n"]]},{"start1":7653,"length1":148,"diffs":[[1,""]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":359,"length1":23,"diffs":[[1,"        s\n"]]},{"start1":2176,"length1":23,"diffs":[[1,"        count = 0\n"]]},{"start1":3282,"length1":51,"diffs":[[1,"                self.moveNumber.append(count)\n"]]},{"start1":3400,"length1":69,"diffs":[[1,"                count += 1\n                if count == 20:\n"]]},{"start1":4576,"length1":23,"diffs":[[1,"        count = 0\n"]]},{"start1":5135,"length1":61,"diffs":[[1,"            count += 1\n            if count == 10:\n"]]},{"start1":5594,"length1":168,"diffs":[[1,"    def returnHome(self):#This method takes a value from my explores so that way once its done the finch can return home!\n"]]},{"start1":6578,"length1":139,"diffs":[[1,""]]}]}]},{"timestamp":1765464342231,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":126,"length1":0,"diffs":[[1,"    y\n"]]},{"start1":1167,"length1":23,"diffs":[[1,"        let count = 0\n"]]},{"start1":1555,"length1":72,"diffs":[[1,"                count += 1\n                if (count == 20) {\n"]]},{"start1":2067,"length1":0,"diffs":[[1,"            finch.setMove(MoveDir.Forward, 35, 50)\n"]]},{"start1":2187,"length1":84,"diffs":[[1,""]]},{"start1":7865,"length1":94,"diffs":[[1,"                this.xValues.pop\n                this.y\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":382,"length1":10,"diffs":[[1,""]]},{"start1":1053,"length1":23,"diffs":[[1,"        count = 0\n"]]},{"start1":1387,"length1":69,"diffs":[[1,"                count += 1\n                if count == 20:\n"]]},{"start1":1813,"length1":0,"diffs":[[1,"            finch.set_move(MoveDir.FORWARD, 35, 50)\n"]]},{"start1":1938,"length1":87,"diffs":[[1,""]]},{"start1":2018,"length1":25,"diffs":[[1,"                break\n        \n"]]},{"start1":6755,"length1":70,"diffs":[[1,"                self.xValues.pop\n                self.y\n"]]}]}]},{"timestamp":1765464723938,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":623,"length1":337,"diffs":[[1,"        while (true) {\n            input.onButtonPressed(Button.A, function on_button_pressed_a() {\n                this.driveSquare()\n            })\n            input.onButtonPressed(Button.B, function on_button_pressed_b() {\n                this.explore()\n            })\n            input.onButtonPressed(Button.AB, function on_button_pressed_ab() {\n                this.dance()\n            })\n        }\n"]]},{"start1":4034,"length1":109,"diffs":[[1,"                    //    def on_button_pressed_a():\n                    //          self.resultsExplore\n                    //    input.on_button_pressed(Button.A, on_button_pressed_a)\n                    input.onButtonPressed(Button.B, function on_button_pressed_b() {\n                        this.returnHome()\n                    })\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":485,"length1":40,"diffs":[[1,"        finch.set_beak(50, 100, 50)\n        while True:\n"]]},{"start1":3616,"length1":110,"diffs":[[1,"                #   def on_button_pressed_a():\n                #         self.resultsExplore\n                #   input.on_button_pressed(Button.A, on_button_pressed_a)\n                    def on_button_pressed_b():\n                        self.returnHome()\n                    input.on_button_pressed(Button.B, on_button_pressed_b)\n"]]}]}]},{"timestamp":1765465302787,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":7844,"length1":24,"diffs":[[1,"//  print(self.yValues)  \n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":382,"length1":0,"diffs":[[1,"        \n\n"]]},{"start1":2018,"length1":0,"diffs":[[1,"\n"]]},{"start1":4029,"length1":49,"diffs":[[1,"                print(f\"The robot moved foward\" )\n"]]},{"start1":6735,"length1":34,"diffs":[[1,"            # print(self.yValues)  \n"]]}]}]},{"timestamp":1765465664939,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":3378,"length1":68,"diffs":[[1,"            #   print(self.xValues)\n            #   print(self.yValues)\n"]]}]}]},{"timestamp":1765473947249,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":3378,"length1":36,"diffs":[[1,"              print(self.xValues)\n"]]}]}]},{"timestamp":1765473951081,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2036,"length1":35,"diffs":[[1,"            this.yValues.push(-180)\n"]]},{"start1":2543,"length1":28,"diffs":[[1,"        while (o) {\n"]]},{"start1":2686,"length1":37,"diffs":[[1,""]]},{"start1":2770,"length1":203,"diffs":[[1,"                    finch.setMove(MoveDir.Forward, y - 30, 50)\n                    this.yValues.push(Math.trunc(y - 30))\n"]]},{"start1":3104,"length1":135,"diffs":[[1,"                    this.yValues.push(Math.trunc(y))\n"]]},{"start1":3287,"length1":135,"diffs":[[1,"                    this.yValues.push(Math.trunc(y))\n"]]},{"start1":3474,"length1":137,"diffs":[[1,"                    this.yValues.push(Math.trunc(180))\n"]]},{"start1":3642,"length1":84,"diffs":[[1,"                this.xValues.push(Math.trunc(x))\n                this.moveNumber.push(this.count)\n                //    print(self.xValues)\n                //    print(self.yValues)\n"]]},{"start1":3965,"length1":143,"diffs":[[1,"                    basic.showString(\"Done Exploring,Headed to Start\")\n                    this.returnHome()\n"]]},{"start1":4123,"length1":33,"diffs":[[1,""]]},{"start1":4934,"length1":29,"diffs":[[1,"        this.returnHome()\n"]]},{"start1":6071,"length1":48,"diffs":[[1,"        } else if (finch.getDistance() == 47) {\n"]]},{"start1":6322,"length1":1903,"diffs":[[1,"        // This method allows the finch to return to its starting loctaion by taking the logged movmets from the exploration phase and reveresing them! \n        for (let item of _py.slice(this.xValues, null, null, -1)) {\n            if (item == 1 || item == 5) {\n                finch.setMove(MoveDir.Backward, this.yValues[-1], 50)\n                _py.py_array_pop(this.xValues)\n                _py.py_array_pop(this.yValues)\n"]]},{"start1":6785,"length1":57,"diffs":[[1,"                finch.setTurn(RLDir.Left, this.yValues[-1], 50)\n                _py.py_array_pop(this.xValues)\n                _py.py_array_pop(this.yValues)\n"]]},{"start1":6979,"length1":58,"diffs":[[1,"                finch.setTurn(RLDir.Right, this.yValues[-1], 50)\n                _py.py_array_pop(this.xValues)\n                _py.py_array_pop(this.yValues)\n"]]},{"start1":7174,"length1":58,"diffs":[[1,"                finch.setTurn(RLDir.Right, this.yValues[-1], 50)\n                _py.py_array_pop(this.xValues)\n                _py.py_array_pop(this.yValues)\n"]]},{"start1":7369,"length1":142,"diffs":[[1,"                finch.setTurn(RLDir.Right, 180, 50)\n                _py.py_array_pop(this.xValues)\n                _py.py_array_pop(this.yValues)\n            } else if (item == 8) {\n                finch.setMove(MoveDir.Backward, 35, 50)\n                _py.py_array_pop(this.xValues)\n                _py.py_array_pop(this.yValues)\n            } else if (item == null) {\n                this.dance()\n"]]},{"start1":7796,"length1":162,"diffs":[[1,""]]},{"start1":7806,"length1":48,"diffs":[[1,""]]},{"start1":7820,"length1":0,"diffs":[[1,"//  print(self.xValues)\n//  print(self.yValues)\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":1847,"length1":37,"diffs":[[1,"            self.yValues.append(-180)\n"]]},{"start1":2273,"length1":25,"diffs":[[1,"        while o:\n"]]},{"start1":2412,"length1":37,"diffs":[[1,""]]},{"start1":2494,"length1":204,"diffs":[[1,"                    finch.set_move(MoveDir.FORWARD,y-30,50)\n                    self.yValues.append(int(y-30))\n"]]},{"start1":2810,"length1":141,"diffs":[[1,"                    self.yValues.append(int(y))\n"]]},{"start1":2980,"length1":141,"diffs":[[1,"                    self.yValues.append(int(y))\n"]]},{"start1":3155,"length1":143,"diffs":[[1,"                    self.yValues.append(int(180))\n"]]},{"start1":3283,"length1":0,"diffs":[[1,"                self.xValues.append(int(x))\n                self.moveNumber.append(self.count)\n"]]},{"start1":3414,"length1":36,"diffs":[[1,"              print(self.yValues)\n"]]},{"start1":3587,"length1":174,"diffs":[[1,"                    basic.show_string(\"Done Exploring,Headed to Start\")\n                    self.returnHome()\n"]]},{"start1":4301,"length1":29,"diffs":[[1,"        self.returnHome()\n"]]},{"start1":5260,"length1":41,"diffs":[[1,"        elif finch.get_distance() == 47:\n"]]},{"start1":5444,"length1":2672,"diffs":[[1,"    def returnHome(self):#This method allows the finch to return to its starting loctaion by taking the logged movmets from the exploration phase and reveresing them! \n        for item in self.xValues[::-1]:\n            if item == 1 or item == 5:\n                finch.set_move(MoveDir.BACKWARD, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 2:\n                finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 3:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 4:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 7:\n                finch.set_turn(RLDir.RIGHT, 180, 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 8:\n                finch.set_move(MoveDir.BACKWARD,35,50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == None:\n"]]},{"start1":6687,"length1":9,"diffs":[[1,"            # print(self.xValues)\n            # print(self.yValues)\n"]]}]}]},{"timestamp":1765474103531,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":7565,"length1":42,"diffs":[[1,"                    item = self.xValues[-1]\n"]]}]}]},{"timestamp":1765476459549,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":7565,"length1":43,"diffs":[[1,"                    item = self.xValues[]\n"]]}]}]},{"timestamp":1765476461781,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2003,"length1":82,"diffs":[[1,"            this.xValues.push(7)\n            this.yValues.push(180)\n"]]},{"start1":2122,"length1":81,"diffs":[[1,"            this.xValues.push(8)\n            this.yValues.push(35)\n"]]},{"start1":2877,"length1":161,"diffs":[[1,"                    this.yValues.push(y - 20)\n                    this.xValues.push(x)\n                    this.moveNumber.push(this.count)\n"]]},{"start1":3230,"length1":156,"diffs":[[1,"                    this.yValues.push(y)\n                    this.xValues.push(x)\n                    this.moveNumber.push(this.count)\n"]]},{"start1":3495,"length1":156,"diffs":[[1,"                    this.yValues.push(y)\n                    this.xValues.push(x)\n                    this.moveNumber.push(this.count)\n"]]},{"start1":3764,"length1":158,"diffs":[[1,"                    this.yValues.push(180)\n                    this.xValues.push(x)\n                    this.moveNumber.push(this.count)\n"]]},{"start1":8374,"length1":75,"diffs":[[1,"            item = this.xValues[-1]\n            magnitude = this.yValues[-1]\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":1812,"length1":76,"diffs":[[1,"            self.xValues.append(7)\n            self.yValues.append(180)\n"]]},{"start1":1936,"length1":75,"diffs":[[1,"            self.xValues.append(8)\n            self.yValues.append(35)\n"]]},{"start1":2598,"length1":150,"diffs":[[1,"                    self.yValues.append(y-20)\n                    self.xValues.append(x)\n                    self.moveNumber.append(self.count)\n"]]},{"start1":2947,"length1":147,"diffs":[[1,"                    self.yValues.append(y)\n                    self.xValues.append(x)\n                    self.moveNumber.append(self.count)\n"]]},{"start1":3210,"length1":147,"diffs":[[1,"                    self.yValues.append(y)\n                    self.xValues.append(x)\n                    self.moveNumber.append(self.count)\n"]]},{"start1":3478,"length1":149,"diffs":[[1,"                    self.yValues.append(180)\n                    self.xValues.append(x)\n                    self.moveNumber.append(self.count)\n"]]},{"start1":7565,"length1":91,"diffs":[[1,"                    item = self.xValues[1]\n                    magnitude = self.yValues[-1]\n"]]}]}]},{"timestamp":1765476582772,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.py","patch":[{"start1":8341,"length1":40,"diffs":[[1,"                    self.xValues.pop()\n"]]}]}]},{"timestamp":1765478968645,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":9165,"length1":46,"diffs":[[1,"            _py.py_array_pop(this.xValues)\n"]]}]}]},{"timestamp":1765478969275,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":45,"length1":47,"diffs":[[1,"    xValues: any[]\n    moveNumber: any[]\n"]]},{"start1":278,"length1":57,"diffs":[[1,"        this.xValues = []\n        this.moveNumber = []\n"]]},{"start1":424,"length1":27,"diffs":[[1,"        this.yValues = []\n"]]},{"start1":8366,"length1":26,"diffs":[[1,"        let item: any;\n"]]},{"start1":9211,"length1":128,"diffs":[[1,"            _py.py_array_pop(this.yValues)\n            console.log(this.xValues)\n            console.log(this.yValues)\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":196,"length1":166,"diffs":[[1,"        self.xValues = [] \n        self.moveNumber = [] #Each run stores its movement data here so it can be acsesed across every method\n        self.yValues = []\n"]]},{"start1":8381,"length1":127,"diffs":[[1,"                    self.yValues.pop()\n                    print(self.xValues) \n                    print(self.yValues)\n"]]}]}]}],"snapshots":[{"timestamp":1765304834669,"editorVersion":"8.0.18","text":{"main.ts":"","README.md":"","main.py":"\n","pxt.json":"{\n    \"name\": \"Finch Project Sam and Henry \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\",\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1765312947533,"editorVersion":"8.0.18","text":{"main.ts":"","README.md":"","main.py":"finch.start_finch()\n\n\nclass SamHenryFinchCode: #The idea is we have a class for the code that way we can make decions about exploration and clearly defined movement methods\n    \n    \n    def __init__(self):\n        self.xValues = [] \n        self.moveNumber = [] #Each run stores its movement data here so it can be acsesed across every method\n        self.yValues = []\n    \n    def selectMode(self):#This is where the user can select what they want their finch to do\n        finch.set_beak(255, 255, 255)\n        def on_button_pressed_a():\n            self.driveSquare()\n        input.on_button_pressed(Button.A, on_button_pressed_a)\n        def on_button_pressed_b():\n            self.explore()\n        input.on_button_pressed(Button.B, on_button_pressed_b)\n        def on_button_pressed_ab():\n            self.dance()\n        input.on_button_pressed(Button.AB, on_button_pressed_ab)\n\n    def driveSquare(self):#the driveSquare method aloows our finch to drive in a set path\n        x = True\n        count = 0\n        while x:\n            while finch.get_distance() >= 30: #this is how we deterine if we need to do obstacle avodiance\n                for i in range(4):\n                    finch.set_move(MoveDir.FORWARD, 10, 50)\n                    finch.set_turn(RLDir.RIGHT, 90, 50)\n                    self.checkDistance()\n                count += 1\n                if count == 20:\n                    x = False\n                    self.dance()\n            finch.stop_motors()\n            self.checkDistance()\n    def checkDistance(self):\n        if finch.get_distance() < 30:\n            self.lightSelection()\n            finch.set_turn(RLDir.LEFT,180,50)\n            finch.set_move(MoveDir.FORWARD, 35, 50)\n    def explore(self):#the explore method is what we are going to use to have the robot roam around the room\n        x = 0\n        o = True\n        count = 0\n        finch.set_beak(0, 0, 100)\n        while o:\n            finch.set_beak(0, 0, 100)\n            x = randint(1, 5)\n            if x == 1 or x == 5:\n                y = finch.get_distance()\n                finch.set_move(MoveDir.FORWARD,y-30,50)\n                self.yValues.append(int(y-30))\n                self.checkDistance()\n            elif x == 2:\n                y = randint(10,90)\n                finch.set_turn(RLDir.RIGHT, y, 50)\n                self.checkDistance()\n                self.yValues.append(int(-y))\n            elif x == 3:\n                y = randint(10,90)\n                finch.set_turn(RLDir.LEFT, y, 50)\n                self.yValues.append(int(-y))\n                self.checkDistance()\n            elif x == 4:\n                finch.set_turn(RLDir.RIGHT, 180, 50)\n                self.yValues.append(int(-180))\n                self.checkDistance()\n            self.xValues.append(int(x))\n            self.moveNumber.append(count)\n            # print(self.xValues)\n            # print(self.yValues)\n            count += 1\n            if count == 20:\n                self.returnHome()\n                break\n            \n    def dance(self):#Makes the robot dance\n        count = 0\n        x = True\n        while x:\n            v = randint(0,100)\n            z = randint(0,100)\n            y = randint(0,100)\n            r = randint(45, 125)\n            finch.set_beak(v, y, z)\n            finch.set_tail(TailPort.ONE, y, z, v)\n            finch.set_tail(TailPort.TWO, z, y, v)\n            finch.set_tail(TailPort.THREE, z, y, v)\n            finch.set_tail(TailPort.FOUR, y, z, v)\n            finch.set_turn(RLDir.RIGHT, r, 75)\n            finch.set_turn(RLDir.LEFT, r, 75)\n            count += 1\n            if count == 30:\n                x = False\n                self.selectMode()\n    def lightSelection(self):#how we determine what light colours to use for the robot\n        if finch.get_distance() < 30:\n            finch.set_beak(100, 0, 0)\n        \n    def returnHome(self):#This method takes a value from my explores so taht way once its done the finch can return home!\n        for item in self.xValues[::-1]:\n            if item == 1 or item == 5:\n                finch.set_move(MoveDir.BACKWARD, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 2:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 3:\n                finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 4:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == None:\n                self.dance()\n            # print(self.xValues)\n            # print(self.yValues)\n\n\n\n        \nrobot = SamHenryFinchCode()\nrobot.selectMode()","pxt.json":"{\n    \"name\": \"Finch Project Sam and Henry \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-finch\": \"github:birdbraintechnologies/pxt-finch#v0.0.5\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\"\n}\n"}},{"timestamp":1765386698130,"editorVersion":"8.0.18","text":{"main.ts":"","README.md":"","main.py":"finch.start_finch()\n\nclass SamHenryFinchCode: #The idea is we have a class for the code that way we can make decions about exploration and clearly defined movement methods\n    def __init__(self):\n        self.xValues = [] \n        self.moveNumber = [] #Each run stores its movement data here so it can be acsesed across every method\n        self.yValues = []\n    def selectMode(self):#This is where the user can select what they want their finch to do\n        finch.set_beak(50, 100, 50)\n        def on_button_pressed_a():\n            self.driveSquare()\n        input.on_button_pressed(Button.A, on_button_pressed_a)\n        def on_button_pressed_b():\n            self.explore()\n        input.on_button_pressed(Button.B, on_button_pressed_b)\n        def on_button_pressed_ab():\n            self.dance()\n        input.on_button_pressed(Button.AB, on_button_pressed_ab)\n    def driveSquare(self):#the driveSquare method aloows our finch to drive in a set path\n        x = True\n        count = 0\n        while x:\n            while finch.get_distance() >= 30: #this is how we deterine if we need to do obstacle avodiance\n                for i in range(4):\n                    finch.set_move(MoveDir.FORWARD, 10, 50)\n                    finch.set_turn(RLDir.RIGHT, 90, 50)\n                    self.checkDistance()\n                count += 1\n                if count == 20:\n                    x = False\n                    self.dance()\n            finch.stop_motors()\n            self.checkDistance()\n    def checkDistance(self):#We check the distance so that way we can stay away from anything that may get in our way\n        while finch.get_distance() < 30:\n            self.lightSelection()\n            finch.set_turn(RLDir.LEFT,180,50)\n            finch.set_move(MoveDir.FORWARD, 35, 50)\n            if finch.get_distance() >= 30:\n                break\n        \n    def explore(self):#the explore method is what we are going to use to have the robot roam around the room\n        x = 0\n        o = True\n        count = 0\n        finch.set_beak(0, 0, 100)\n        while o:\n            while finch.get_distance() >= 30:\n                finch.set_beak(0, 0, 100)\n                x = randint(1, 5)\n                if x == 1 or x == 5:\n                    y = finch.get_distance()\n                    finch.set_move(MoveDir.FORWARD,y-30,50)\n                    self.yValues.append(int(y-30))\n                    self.checkDistance()\n                elif x == 2:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.RIGHT, y, 50)\n                    self.checkDistance()\n                    self.yValues.append(int(-y))\n                elif x == 3:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.LEFT, y, 50)\n                    self.yValues.append(int(-y))\n                    self.checkDistance()\n                elif x == 4:\n                    finch.set_turn(RLDir.RIGHT, 180, 50)\n                    self.yValues.append(int(-180))\n                    self.checkDistance()\n                self.checkDistance()\n                self.xValues.append(int(x))\n                self.moveNumber.append(count)\n            #   print(self.xValues)\n            #   print(self.yValues)\n                count += 1\n                if count == 20:\n                    o = False\n                    finch.stop_motors()\n                #   def on_button_pressed_a():\n                #         self.resultsExplore\n                #   input.on_button_pressed(Button.A, on_button_pressed_a)\n                    def on_button_pressed_b():\n                        self.returnHome()\n                    input.on_button_pressed(Button.B, on_button_pressed_b)\n    def resultsExplore(self):#Gives the option for the user to print the logs of what movement the finch made on whichever turn\n        for item in self.xValues:#It would be cool to have it where the user could choose which turn they want or to see which movement was most common\n            if item == 1 or item == 5:\n                print(f\"The robot moved foward\" )\n            if item == 2:\n                print(\"The robot turned to the right\")\n            if item == 3:\n                print(\"The robot turned to the left\")\n            if item == 4:\n                print(\"The robot turned around\")\n        self.returnHome()\n    def dance(self):#Makes the robot dance by going back and forth at random angles\n        count = 0\n        x = True\n        while x:\n            v = randint(0,100)\n            z = randint(0,100)\n            y = randint(0,100)\n            r = randint(45, 125)\n            finch.set_beak(v, y, z)\n            finch.set_tail(TailPort.ONE, y, z, v)\n            finch.set_tail(TailPort.TWO, z, y, v)\n            finch.set_tail(TailPort.THREE, z, y, v)\n            finch.set_tail(TailPort.FOUR, y, z, v)\n            finch.set_turn(RLDir.RIGHT, 720, 80)\n            finch.set_turn(RLDir.RIGHT, r, 75)\n            finch.set_turn(RLDir.LEFT, r, 75)\n            count += 1\n            if count == 10:\n                x = False\n                self.selectMode()\n    def lightSelection(self):#how we determine what light colours to use for the robot\n        if finch.get_distance() < 30:\n            finch.set_beak(100, 0, 0) \n        if finch.get_distance() > 30:\n            finch.set_beak(0, 100, 0) \n        if finch.get_distance() == 47:\n            finch.set_beak(69, 67, 41)\n            self.dance() \n    def returnHome(self):#This method takes a value from my explores so that way once its done the finch can return home!\n        for item in self.xValues[::-1]:\n            if item == 1 or item == 5:\n                finch.set_move(MoveDir.BACKWARD, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 2:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 3:\n                finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 4:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == None:\n                self.dance()\n            # print(self.xValues)\n            # print(self.yValues)  \nrobot = SamHenryFinchCode()\nrobot.selectMode()","pxt.json":"{\n    \"name\": \"Finch Project Sam and Henry \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-finch\": \"github:birdbraintechnologies/pxt-finch#v0.0.5\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\"\n}\n"}},{"timestamp":1765401646032,"editorVersion":"8.0.18","text":{"main.ts":"","README.md":"","main.py":"finch.start_finch()\n\nclass SamHenryFinchCode: #The idea is we have a class for the code that way we can make decions about exploration and clearly defined movement methods\n    def __init__(self):\n        self.xValues = [] \n        self.moveNumber = [] #Each run stores its movement data here so it can be acsesed across every method\n        self.yValues = []\n    def selectMode(self):#This is where the user can select what they want their finch to do\n        finch.set_beak(50, 100, 50)\n        def on_button_pressed_a():\n            self.driveSquare()\n        input.on_button_pressed(Button.A, on_button_pressed_a)\n        def on_button_pressed_b():\n            self.explore()\n        input.on_button_pressed(Button.B, on_button_pressed_b)\n        def on_button_pressed_ab():\n            self.dance()\n        input.on_button_pressed(Button.AB, on_button_pressed_ab)\n    def driveSquare(self):#the driveSquare method alows our finch to drive in a set path\n        x = True\n        count = 0\n        while x:\n            while finch.get_distance() >= 30: #this is how we deterine if we need to do obstacle avodiance\n                for i in range(4):\n                    finch.set_move(MoveDir.FORWARD, 10, 50)\n                    finch.set_turn(RLDir.RIGHT, 90, 50)\n                    self.checkDistance()\n                count += 1\n                if count == 20:\n                    x = False\n                    self.dance()\n            finch.stop_motors()\n            self.checkDistance()\n    def checkDistance(self):#We check the distance so that way we can stay away from anything that may get in our way\n        while finch.get_distance() < 30:\n            self.lightSelection()\n            finch.set_turn(RLDir.LEFT,180,50)\n            finch.set_move(MoveDir.FORWARD, 35, 50)\n            self.xValues.append(7)\n            self.yValues.append(-180)\n            self.yValues.append(35)\n\n            if finch.get_distance() >= 30:\n                break\n        \n    def explore(self):#the explore method is what we are going to use to have the robot roam around the room\n        x = 0\n        o = True\n        count = 0\n        finch.set_beak(0, 0, 100)\n        while o:\n            while finch.get_distance() >= 30:\n                finch.set_beak(0, 0, 100)\n                x = randint(1, 5)\n                if x == 1 or x == 5:\n                    y = finch.get_distance()\n                    finch.set_move(MoveDir.FORWARD,y-30,50)\n                    self.yValues.append(int(y-30))\n                    self.checkDistance()\n                elif x == 2:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.RIGHT, y, 50)\n                    self.checkDistance()\n                    self.yValues.append(int(-y))\n                elif x == 3:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.LEFT, y, 50)\n                    self.yValues.append(int(-y))\n                    self.checkDistance()\n                elif x == 4:\n                    finch.set_turn(RLDir.RIGHT, 180, 50)\n                    self.yValues.append(int(-180))\n                    self.checkDistance()\n                self.checkDistance()\n                self.xValues.append(int(x))\n                self.moveNumber.append(count)\n            #   print(self.xValues)\n            #   print(self.yValues)\n                count += 1\n                if count == 20:\n                    o = False\n                    finch.stop_motors()\n                #   def on_button_pressed_a():\n                #         self.resultsExplore\n                #   input.on_button_pressed(Button.A, on_button_pressed_a)\n                    def on_button_pressed_b():\n                        self.returnHome()\n                    input.on_button_pressed(Button.B, on_button_pressed_b)\n    def resultsExplore(self):#Gives the option for the user to print the logs of what movement the finch made on whichever turn\n        for item in self.xValues:#It would be cool to have it where the user could choose which turn they want or to see which movement was most common\n            if item == 1 or item == 5:\n                print(f\"The robot moved foward\" )\n            if item == 2:\n                print(\"The robot turned to the right\")\n            if item == 3:\n                print(\"The robot turned to the left\")\n            if item == 4:\n                print(\"The robot turned around\")\n        self.returnHome()\n    def dance(self):#Makes the robot dance by going back and forth at random angles\n        count = 0\n        x = True\n        while x:\n            v = randint(0,100)\n            z = randint(0,100)\n            y = randint(0,100)\n            r = randint(45, 125)\n            finch.set_beak(v, y, z)\n            finch.set_tail(TailPort.ONE, y, z, v)\n            finch.set_tail(TailPort.TWO, z, y, v)\n            finch.set_tail(TailPort.THREE, z, y, v)\n            finch.set_tail(TailPort.FOUR, y, z, v)\n            finch.set_turn(RLDir.RIGHT, 720, 80)\n            finch.set_turn(RLDir.RIGHT, r, 75)\n            finch.set_turn(RLDir.LEFT, r, 75)\n            count += 1\n            if count == 10:\n                x = False\n                self.selectMode()\n    def lightSelection(self):#how we determine what light colours to use for the robot\n        if finch.get_distance() < 30:\n            finch.set_beak(100, 0, 0) \n        if finch.get_distance() > 30:\n            finch.set_beak(0, 100, 0) \n        if finch.get_distance() == 47:\n            finch.set_beak(69, 67, 41)\n            self.dance() \n    def returnHome(self):#This method takes a value from my explores so that way once its done the finch can return home!\n        for item in self.xValues[::-1]:\n            if item == 1 or item == 5:\n                finch.set_move(MoveDir.BACKWARD, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 2:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 3:\n                finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 4:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 7:\n                pass\n            elif item == None:\n                self.dance()\n            # print(self.xValues)\n            # print(self.yValues)  \nrobot = SamHenryFinchCode()\nrobot.selectMode()","pxt.json":"{\n    \"name\": \"Finch Project Sam and Henry \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-finch\": \"github:birdbraintechnologies/pxt-finch#v0.0.5\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\"\n}\n"}},{"timestamp":1765462395271,"editorVersion":"8.0.18","text":{"main.ts":"","README.md":"","main.py":"finch.start_finch()\n\nclass SamHenryFinchCode: #The idea is we have a class for the code that way we can make decions about exploration and clearly defined movement methods\n    def __init__(self):\n        self.xValues = [] \n        self.moveNumber = [] #Each run stores its movement data here so it can be acsesed across every method\n        self.yValues = []\n    def selectMode(self):#This is where the user can select what they want their finch to do\n        finch.set_beak(50, 100, 50)\n        def on_button_pressed_a():\n            self.driveSquare()\n        input.on_button_pressed(Button.A, on_button_pressed_a)\n        def on_button_pressed_b():\n            self.explore()\n        input.on_button_pressed(Button.B, on_button_pressed_b)\n        def on_button_pressed_ab():\n            self.dance()\n        input.on_button_pressed(Button.AB, on_button_pressed_ab)\n    def driveSquare(self):#the driveSquare method alows our finch to drive in a set path\n        x = True\n        count = 0\n        while x:\n            while finch.get_distance() >= 30: #this is how we deterine if we need to do obstacle avodiance\n                for i in range(4):\n                    finch.set_move(MoveDir.FORWARD, 10, 50)\n                    finch.set_turn(RLDir.RIGHT, 90, 50)\n                    self.checkDistance()\n                count += 1\n                if count == 20:\n                    x = False\n                    self.dance()\n            finch.stop_motors()\n            self.checkDistance()\n    def checkDistance(self):#We check the distance so that way we can stay away from anything that may get in our way\n        while finch.get_distance() < 30:\n            self.lightSelection()\n            finch.set_turn(RLDir.LEFT,180,50)\n            finch.set_move(MoveDir.FORWARD, 35, 50)\n            self.xValues.append(7)\n            self.yValues.append(-180)\n            self.yValues.append(35)\n\n            if finch.get_distance() >= 30:\n                break\n        \n    def explore(self):#the explore method is what we are going to use to have the robot roam around the room\n        x = 0\n        o = True\n        count = 0\n        finch.set_beak(0, 0, 100)\n        while o:\n            while finch.get_distance() >= 30:\n                finch.set_beak(0, 0, 100)\n                x = randint(1, 5)\n                if x == 1 or x == 5:\n                    y = finch.get_distance()\n                    finch.set_move(MoveDir.FORWARD,y-30,50)\n                    self.yValues.append(int(y-30))\n                    self.checkDistance()\n                elif x == 2:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.RIGHT, y, 50)\n                    self.checkDistance()\n                    self.yValues.append(int(y))\n                elif x == 3:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.LEFT, y, 50)\n                    self.yValues.append(int(y))\n                    self.checkDistance()\n                elif x == 4:\n                    finch.set_turn(RLDir.RIGHT, 180, 50)\n                    self.yValues.append(int(180))\n                    self.checkDistance()\n                self.checkDistance()\n                self.xValues.append(int(x))\n                self.moveNumber.append(count)\n            #   print(self.xValues)\n            #   print(self.yValues)\n                count += 1\n                if count == 20:\n                    o = False\n                    finch.stop_motors()\n                #   def on_button_pressed_a():\n                #         self.resultsExplore\n                #   input.on_button_pressed(Button.A, on_button_pressed_a)\n                    def on_button_pressed_b():\n                        self.returnHome()\n                    input.on_button_pressed(Button.B, on_button_pressed_b)\n    def resultsExplore(self):#Gives the option for the user to print the logs of what movement the finch made on whichever turn\n        for item in self.xValues:#It would be cool to have it where the user could choose which turn they want or to see which movement was most common\n            if item == 1 or item == 5:\n                print(f\"The robot moved foward\" )\n            if item == 2:\n                print(\"The robot turned to the right\")\n            if item == 3:\n                print(\"The robot turned to the left\")\n            if item == 4:\n                print(\"The robot turned around\")\n        self.returnHome()\n    def dance(self):#Makes the robot dance by going back and forth at random angles\n        count = 0\n        x = True\n        while x:\n            v = randint(0,100)\n            z = randint(0,100)\n            y = randint(0,100)\n            r = randint(45, 125)\n            finch.set_beak(v, y, z)\n            finch.set_tail(TailPort.ONE, y, z, v)\n            finch.set_tail(TailPort.TWO, z, y, v)\n            finch.set_tail(TailPort.THREE, z, y, v)\n            finch.set_tail(TailPort.FOUR, y, z, v)\n            finch.set_turn(RLDir.RIGHT, 720, 80)\n            finch.set_turn(RLDir.RIGHT, r, 75)\n            finch.set_turn(RLDir.LEFT, r, 75)\n            count += 1\n            if count == 10:\n                x = False\n                self.selectMode()\n    def lightSelection(self):#how we determine what light colours to use for the robot\n        if finch.get_distance() < 30:\n            finch.set_beak(100, 0, 0) \n        if finch.get_distance() > 30:\n            finch.set_beak(0, 100, 0) \n        if finch.get_distance() == 47:\n            finch.set_beak(69, 67, 41)\n            self.dance() \n    def returnHome(self):#This method takes a value from my explores so that way once its done the finch can return home!\n        for item in self.xValues[::-1]:\n            if item == 1 or item == 5:\n                finch.set_move(MoveDir.BACKWARD, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 2:\n                finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 3:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 4:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 7:\n                finch.set_turn(RLDir.RIGHT, 180, 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == None:\n                self.dance()\n            # print(self.xValues)\n            # print(self.yValues)  \nrobot = SamHenryFinchCode()\nrobot.selectMode()","pxt.json":"{\n    \"name\": \"Finch Project Sam and Henry \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-finch\": \"github:birdbraintechnologies/pxt-finch#v0.0.5\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\"\n}\n"}},{"timestamp":1765464267498,"editorVersion":"8.0.18","text":{"main.ts":"","README.md":"","main.py":"finch.start_finch()\n\nclass SamHenryFinchCode: #The idea is we have a class for the code that way we can make decions about exploration and clearly defined movement methods\n    def __init__(self):\n        self.xValues = [] \n        self.moveNumber = [] #Each run stores its movement data here so it can be acsesed across every method\n        self.yValues = []\n        self.count = 0\n    def selectMode(self):#This is where the user can select what they want their finch to do\n        finch.set_beak(50, 100, 50)\n        while True:\n            def on_button_pressed_a():\n                self.driveSquare()\n            input.on_button_pressed(Button.A, on_button_pressed_a)\n            def on_button_pressed_b():\n                self.explore()\n            input.on_button_pressed(Button.B, on_button_pressed_b)\n            def on_button_pressed_ab():\n                self.dance()\n            input.on_button_pressed(Button.AB, on_button_pressed_ab)\n    def driveSquare(self):#the driveSquare method alows our finch to drive in a set path\n        x = True\n        count = 0\n        while x:\n            while finch.get_distance() >= 30: #this is how we deterine if we need to do obstacle avodiance\n                for i in range(4):\n                    finch.set_move(MoveDir.FORWARD, 10, 50)\n                    finch.set_turn(RLDir.RIGHT, 90, 50)\n                    self.checkDistance()\n                count += 1\n                if count == 20:\n                    x = False\n                    self.dance()\n            finch.stop_motors()\n            self.checkDistance()\n    def checkDistance(self):#We check the distance so that way we can stay away from anything that may get in our way\n        while finch.get_distance() < 30:\n            self.lightSelection()\n            finch.set_turn(RLDir.LEFT,180,50)\n            finch.set_move(MoveDir.FORWARD, 35, 50)\n            self.xValues.append(7)\n            self.yValues.append(-180)\n            self.yValues.append(35)\n\n            if finch.get_distance() >= 30:\n                break\n        \n    def explore(self):#the explore method is what we are going to use to have the robot roam around the room\n        x = 0\n        o = True\n        self.count = 0\n        finch.set_beak(0, 0, 100)\n        while o:\n            while finch.get_distance() >= 30:\n                finch.set_beak(0, 0, 100)\n                x = randint(1, 5)\n                if x == 1 or x == 5:\n                    y = finch.get_distance()\n                    finch.set_move(MoveDir.FORWARD,y-30,50)\n                    self.yValues.append(int(y-30))\n                    self.checkDistance()\n                elif x == 2:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.RIGHT, y, 50)\n                    self.checkDistance()\n                    self.yValues.append(int(y))\n                elif x == 3:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.LEFT, y, 50)\n                    self.yValues.append(int(y))\n                    self.checkDistance()\n                elif x == 4:\n                    finch.set_turn(RLDir.RIGHT, 180, 50)\n                    self.yValues.append(int(180))\n                    self.checkDistance()\n                self.checkDistance()\n                self.xValues.append(int(x))\n                self.moveNumber.append(self.count)\n            #   print(self.xValues)\n            #   print(self.yValues)\n                self.count += 1\n                if self.count == 20:\n                    o = False\n                    finch.stop_motors()\n                #   def on_button_pressed_a():\n                #         self.resultsExplore\n                #   input.on_button_pressed(Button.A, on_button_pressed_a)\n                    def on_button_pressed_b():\n                        self.returnHome()\n                    input.on_button_pressed(Button.B, on_button_pressed_b)\n    def resultsExplore(self):#Gives the option for the user to print the logs of what movement the finch made on whichever turn\n        for item in self.xValues:#It would be cool to have it where the user could choose which turn they want or to see which movement was most common\n            if item == 1 or item == 5:\n                print(f\"The robot moved foward\" )\n            if item == 2:\n                print(\"The robot turned to the right\")\n            if item == 3:\n                print(\"The robot turned to the left\")\n            if item == 4:\n                print(\"The robot turned around\")\n        self.returnHome()\n    def dance(self):#Makes the robot dance by going back and forth at random angles\n        self.count = 0\n        x = True\n        while x:\n            v = randint(0,100)\n            z = randint(0,100)\n            y = randint(0,100)\n            r = randint(45, 125)\n            finch.set_beak(v, y, z)\n            finch.set_tail(TailPort.ONE, y, z, v)\n            finch.set_tail(TailPort.TWO, z, y, v)\n            finch.set_tail(TailPort.THREE, z, y, v)\n            finch.set_tail(TailPort.FOUR, y, z, v)\n            finch.set_turn(RLDir.RIGHT, 720, 80)\n            finch.set_turn(RLDir.RIGHT, r, 75)\n            finch.set_turn(RLDir.LEFT, r, 75)\n            self.count += 1\n            if self.count == 10:\n                x = False\n                self.selectMode()\n    def lightSelection(self):#how we determine what light colours to use for the robot\n        if finch.get_distance() < 30:\n            finch.set_beak(100, 0, 0) \n        elif finch.get_distance() == 47:\n            finch.set_beak(69, 67, 41)\n            self.dance() \n        elif finch.get_distance() > 30:\n            finch.set_beak(0, 100, 0)\n    def returnHome(self):#This method allows the finch to return to its starting loctaion by taking the logged movmets from the exploration phase and reveresing them! \n        for item in self.xValues[::-1]:\n            if item == 1 or item == 5:\n                finch.set_move(MoveDir.BACKWARD, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 2:\n                finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 3:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 4:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 7:\n                finch.set_turn(RLDir.RIGHT, 180, 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == None:\n                self.dance()\n            # print(self.xValues)\n            # print(self.yValues)  \nrobot = SamHenryFinchCode()\nrobot.selectMode()","pxt.json":"{\n    \"name\": \"Finch Project Sam and Henry \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-finch\": \"github:birdbraintechnologies/pxt-finch#v0.0.5\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\"\n}\n"}},{"timestamp":1765473947249,"editorVersion":"8.0.18","text":{"main.ts":"","README.md":"","main.py":"finch.start_finch()\n\nclass SamHenryFinchCode: #The idea is we have a class for the code that way we can make decions about exploration and clearly defined movement methods\n    def __init__(self):\n        self.xValues = [] \n        self.moveNumber = [] #Each run stores its movement data here so it can be acsesed across every method\n        self.yValues = []\n        self.count = 0\n    def selectMode(self):#This is where the user can select what they want their finch to do\n            finch.set_beak(50, 100, 50)\n            def on_button_pressed_a():\n                self.driveSquare()\n            input.on_button_pressed(Button.A, on_button_pressed_a)\n            def on_button_pressed_b():\n                self.explore()\n            input.on_button_pressed(Button.B, on_button_pressed_b)\n            def on_button_pressed_ab():\n                self.dance()\n            input.on_button_pressed(Button.AB, on_button_pressed_ab)\n    def driveSquare(self):#the driveSquare method alows our finch to drive in a set path\n        x = True\n        self.count = 0\n        while x:\n            while finch.get_distance() >= 30: #this is how we deterine if we need to do obstacle avodiance\n                for i in range(4):\n                    finch.set_move(MoveDir.FORWARD, 10, 50)\n                    finch.set_turn(RLDir.RIGHT, 90, 50)\n                    self.checkDistance()\n                self.count += 1\n                if self.count == 20:\n                    x = False\n                    self.dance()\n            finch.stop_motors()\n            self.checkDistance()\n    def checkDistance(self):#We check the distance so that way we can stay away from anything that may get in our way\n        while finch.get_distance() < 30:\n            self.lightSelection()\n            finch.set_turn(RLDir.LEFT,180,50)\n            self.xValues.append(7)\n            self.yValues.append(-180)\n            finch.set_move(MoveDir.FORWARD, 35, 50)\n            self.xValues.append(8)\n            self.yValues.append(35)\n            if finch.get_distance() >= 30:\n                break   \n    def explore(self):#the explore method is what we are going to use to have the robot roam around the room\n        x = 0\n        o = True\n        self.count = 0\n        finch.set_beak(0, 0, 100)\n        while o:\n            while finch.get_distance() >= 30:\n                finch.set_beak(0, 0, 100)\n                x = randint(1, 5)\n                if x == 1 or x == 5:\n                    y = finch.get_distance()\n                    finch.set_move(MoveDir.FORWARD,y-30,50)\n                    self.yValues.append(int(y-30))\n                    self.checkDistance()\n                elif x == 2:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.RIGHT, y, 50)\n                    self.checkDistance()\n                    self.yValues.append(int(y))\n                elif x == 3:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.LEFT, y, 50)\n                    self.yValues.append(int(y))\n                    self.checkDistance()\n                elif x == 4:\n                    finch.set_turn(RLDir.RIGHT, 180, 50)\n                    self.yValues.append(int(180))\n                    self.checkDistance()\n                self.checkDistance()\n                self.xValues.append(int(x))\n                self.moveNumber.append(self.count)\n            #   print(self.xValues)\n            #   print(self.yValues)\n                self.count += 1\n                if self.count == 20:\n                    o = False\n                    finch.stop_motors()\n                    basic.show_string(\"Done Exploring,Headed to Start\")\n                    self.returnHome()\n    def resultsExplore(self):#Gives the option for the user to print the logs of what movement the finch made on whichever turn\n        for item in self.xValues:#It would be cool to have it where the user could choose which turn they want or to see which movement was most common\n            if item == 1 or item == 5:\n                print(f\"The robot moved foward\")\n            if item == 2:\n                print(\"The robot turned to the right\")\n            if item == 3:\n                print(\"The robot turned to the left\")\n            if item == 4:\n                print(\"The robot turned around\")\n        self.returnHome()\n    def dance(self):#Makes the robot dance by going back and forth at random angles\n        self.count = 0\n        x = True\n        while x:\n            v = randint(0,100)\n            z = randint(0,100)\n            y = randint(0,100)\n            r = randint(45, 125)\n            finch.set_beak(v, y, z)\n            finch.set_tail(TailPort.ONE, y, z, v)\n            finch.set_tail(TailPort.TWO, z, y, v)\n            finch.set_tail(TailPort.THREE, z, y, v)\n            finch.set_tail(TailPort.FOUR, y, z, v)\n            finch.set_turn(RLDir.RIGHT, 720, 80)\n            finch.set_turn(RLDir.RIGHT, r, 75)\n            finch.set_turn(RLDir.LEFT, r, 75)\n            self.count += 1\n            if self.count == 10:\n                x = False\n                self.selectMode()\n    def lightSelection(self):#how we determine what light colours to use for the robot\n        if finch.get_distance() < 30:\n            finch.set_beak(100, 0, 0) \n        elif finch.get_distance() == 47:\n            finch.set_beak(69, 67, 41)\n            self.dance() \n        elif finch.get_distance() > 30:\n            finch.set_beak(0, 100, 0)\n    def returnHome(self):#This method allows the finch to return to its starting loctaion by taking the logged movmets from the exploration phase and reveresing them! \n        for item in self.xValues[::-1]:\n            if item == 1 or item == 5:\n                finch.set_move(MoveDir.BACKWARD, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 2:\n                finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 3:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 4:\n                finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 7:\n                finch.set_turn(RLDir.RIGHT, 180, 50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == 8:\n                finch.set_move(MoveDir.BACKWARD,35,50)\n                self.xValues.pop()\n                self.yValues.pop()\n            elif item == None:\n                self.dance()\n            # print(self.xValues)\n            # print(self.yValues)\nrobot = SamHenryFinchCode()\nrobot.selectMode()","pxt.json":"{\n    \"name\": \"Finch Project Sam and Henry \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-finch\": \"github:birdbraintechnologies/pxt-finch#v0.0.5\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\"\n}\n"}},{"timestamp":1765476459549,"editorVersion":"8.0.18","text":{"main.ts":"","README.md":"","main.py":"finch.start_finch()\n\nclass SamHenryFinchCode: #The idea is we have a class for the code that way we can make decions about exploration and clearly defined movement methods\n    def __init__(self):\n        self.xValues = [] \n        self.moveNumber = [] #Each run stores its movement data here so it can be acsesed across every method\n        self.yValues = []\n        self.count = 0\n    def selectMode(self):#This is where the user can select what they want their finch to do\n            finch.set_beak(50, 100, 50)\n            def on_button_pressed_a():\n                self.driveSquare()\n            input.on_button_pressed(Button.A, on_button_pressed_a)\n            def on_button_pressed_b():\n                self.explore()\n            input.on_button_pressed(Button.B, on_button_pressed_b)\n            def on_button_pressed_ab():\n                self.dance()\n            input.on_button_pressed(Button.AB, on_button_pressed_ab)\n    def driveSquare(self):#the driveSquare method alows our finch to drive in a set path\n        x = True\n        self.count = 0\n        while x:\n            while finch.get_distance() >= 30: #this is how we deterine if we need to do obstacle avodiance\n                for i in range(4):\n                    finch.set_move(MoveDir.FORWARD, 10, 50)\n                    finch.set_turn(RLDir.RIGHT, 90, 50)\n                    self.checkDistance()\n                self.count += 1\n                if self.count == 20:\n                    x = False\n                    self.dance()\n            finch.stop_motors()\n            self.checkDistance()\n    def checkDistance(self):#We check the distance so that way we can stay away from anything that may get in our way\n        while finch.get_distance() < 30:\n            self.lightSelection()\n            finch.set_turn(RLDir.LEFT,180,50)\n            self.xValues.append(7)\n            self.yValues.append(180)\n            finch.set_move(MoveDir.FORWARD, 35, 50)\n            self.xValues.append(8)\n            self.yValues.append(35)\n            if finch.get_distance() >= 30:\n                break   \n    def explore(self):#the explore method is what we are going to use to have the robot roam around the room\n        x = 0\n        o = True\n        self.count = 0\n        finch.set_beak(0, 0, 100)\n        while o == True:\n            while finch.get_distance() >= 30:\n                finch.set_beak(0, 0, 100)\n                x = randint(1, 5)\n                self.checkDistance()\n                if x == 1 or x == 5:\n                    y = finch.get_distance()\n                    finch.set_move(MoveDir.FORWARD,y-20,50)\n                    self.yValues.append(y-20)\n                    self.xValues.append(x)\n                    self.moveNumber.append(self.count)\n                    self.checkDistance()\n                elif x == 2:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.RIGHT, y, 50)\n                    self.checkDistance()\n                    self.yValues.append(y)\n                    self.xValues.append(x)\n                    self.moveNumber.append(self.count)\n                elif x == 3:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.LEFT, y, 50)\n                    self.yValues.append(y)\n                    self.xValues.append(x)\n                    self.moveNumber.append(self.count)\n                    self.checkDistance()\n                elif x == 4:\n                    finch.set_turn(RLDir.RIGHT, 180, 50)\n                    self.yValues.append(180)\n                    self.xValues.append(x)\n                    self.moveNumber.append(self.count)\n                    self.checkDistance()\n                self.checkDistance()\n                print(self.xValues)\n                print(self.yValues)\n                self.count += 1\n                if self.count == 20:\n                    o = False\n                    finch.stop_motors()\n                    # basic.show_string(\"Done Exploring,Headed to Start\")\n                    self.returnHomeTWO()\n                    break\n            self.checkDistance()\n    def resultsExplore(self):#Gives the option for the user to print the logs of what movement the finch made on whichever turn\n        for item in self.xValues:#It would be cool to have it where the user could choose which turn they want or to see which movement was most common\n            if item == 1 or item == 5:\n                print(f\"The robot moved foward\")\n            if item == 2:\n                print(\"The robot turned to the right\")\n            if item == 3:\n                print(\"The robot turned to the left\")\n            if item == 4:\n                print(\"The robot turned around\")\n        self.returnHomeTWO()\n    def dance(self):#Makes the robot dance by going back and forth at random angles\n        self.count = 0\n        x = True\n        while x:\n            v = randint(0,100)\n            z = randint(0,100)\n            y = randint(0,100)\n            r = randint(45, 125)\n            finch.set_beak(v, y, z)\n            finch.set_tail(TailPort.ONE, y, z, v)\n            finch.set_tail(TailPort.TWO, z, y, v)\n            finch.set_tail(TailPort.THREE, z, y, v)\n            finch.set_tail(TailPort.FOUR, y, z, v)\n            finch.set_turn(RLDir.RIGHT, 720, 80)\n            finch.set_turn(RLDir.RIGHT, r, 75)\n            finch.set_turn(RLDir.LEFT, r, 75)\n            self.count += 1\n            if self.count == 10:\n                x = False\n                self.selectMode()\n    def lightSelection(self):#how we determine what light colours to use for the robot\n        if finch.get_distance() < 30:\n            finch.set_beak(100, 0, 0) \n        elif finch.get_distance() == 95:\n            finch.set_beak(69, 67, 41)\n            self.dance() \n        elif finch.get_distance() > 30:\n            finch.set_beak(0, 100, 0)\n    def returnHome(self):#V1 doesnt work\n        pass#This method allows the finch to return to its starting loctaion by taking the logged movmets from the exploration phase and reveresing them! \n        #     finch.set_beak(100, 0, 100) first version of return home didnt work too well\n        #     for item in self.xValues[::-1]:\n        #         if item == 1 or item == 5:\n        #             finch.set_move(MoveDir.BACKWARD, self.yValues[-1], 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 2:\n        #             finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 3:\n        #             finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 4:\n        #             finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 7:\n        #             finch.set_turn(RLDir.RIGHT, 180, 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 8:\n        #             finch.set_move(MoveDir.BACKWARD,35,50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         else:\n        #             basic.show_number(1)\n        #         print(self.xValues)\n        #         print(self.yValues)\n        #     self.dance()\n    def returnHomeTWO(self):\n                finch.set_beak(100, 0, 100)\n                while self.xValues:\n                    item = self.xValues[-1]\n                    magnitude = self.yValues[-1]\n                    if item == 1 or item == 5 or item == 8: \n                        finch.set_move(MoveDir.BACKWARD, magnitude, 50)\n                    elif item == 2: \n                        finch.set_turn(RLDir.LEFT, magnitude, 50)\n                    elif item == 3:\n                        finch.set_turn(RLDir.RIGHT, magnitude, 50)\n                    elif item == 4: \n                        finch.set_turn(RLDir.RIGHT, magnitude, 50)\n                    elif item == 7: \n                        finch.set_turn(RLDir.RIGHT, magnitude, 50)\n                    else:\n                        basic.show_string(\"Done\")\n                        break\n                    self.xValues.pop()\n                    self.yValues.pop()\n                    print(self.xValues) \n                    print(self.yValues)\n                finch.stop_motors()\n                self.dance()\n        \nrobot = SamHenryFinchCode()\nrobot.selectMode()","pxt.json":"{\n    \"name\": \"Finch Project Sam and Henry \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-finch\": \"github:birdbraintechnologies/pxt-finch#v0.0.5\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\"\n}\n"}},{"timestamp":1765478968645,"editorVersion":"8.0.18","text":{"main.ts":"","README.md":"","main.py":"finch.start_finch()\n\nclass SamHenryFinchCode: #The idea is we have a class for the code that way we can make decions about exploration and clearly defined movement methods\n    def __init__(self):\n        self.xValues = [] \n        self.moveNumber = [] #Each run stores its movement data here so it can be acsesed across every method\n        self.yValues = []\n        self.count = 0\n    def selectMode(self):#This is where the user can select what they want their finch to do\n            finch.set_beak(50, 100, 50)\n            def on_button_pressed_a():\n                self.driveSquare()\n            input.on_button_pressed(Button.A, on_button_pressed_a)\n            def on_button_pressed_b():\n                self.explore()\n            input.on_button_pressed(Button.B, on_button_pressed_b)\n            def on_button_pressed_ab():\n                self.dance()\n            input.on_button_pressed(Button.AB, on_button_pressed_ab)\n    def driveSquare(self):#the driveSquare method alows our finch to drive in a set path\n        x = True\n        self.count = 0\n        while x:\n            while finch.get_distance() >= 30: #this is how we deterine if we need to do obstacle avodiance\n                for i in range(4):\n                    finch.set_move(MoveDir.FORWARD, 10, 50)\n                    finch.set_turn(RLDir.RIGHT, 90, 50)\n                    self.checkDistance()\n                self.count += 1\n                if self.count == 20:\n                    x = False\n                    self.dance()\n            finch.stop_motors()\n            self.checkDistance()\n    def checkDistance(self):#We check the distance so that way we can stay away from anything that may get in our way\n        while finch.get_distance() < 30:\n            self.lightSelection()\n            finch.set_turn(RLDir.LEFT,180,50)\n            self.xValues.insert(0,7)\n            self.yValues.insert(0,180)\n            finch.set_move(MoveDir.FORWARD, 35, 50)\n            self.xValues.insert(0,8)\n            self.yValues.insert(0,35)\n            if finch.get_distance() >= 30:\n                break   \n    def explore(self):#the explore method is what we are going to use to have the robot roam around the room\n        x = 0\n        o = True\n        self.count = 0\n        finch.set_beak(0, 0, 100)\n        while o == True:\n            while finch.get_distance() >= 30:\n                finch.set_beak(0, 0, 100)\n                x = randint(1, 5)\n                self.checkDistance()\n                if x == 1 or x == 5:\n                    y = finch.get_distance()\n                    finch.set_move(MoveDir.FORWARD,y-20,50)\n                    self.yValues.insert(0,y-20)\n                    self.xValues.insert(0,x)\n                    self.moveNumber.insert(0,self.count)\n                    self.checkDistance()\n                elif x == 2:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.RIGHT, y, 50)\n                    self.checkDistance()\n                    self.yValues.insert(0,y)\n                    self.xValues.insert(0,x)\n                    self.moveNumber.insert(0,self.count)\n                elif x == 3:\n                    y = randint(10,90)\n                    finch.set_turn(RLDir.LEFT, y, 50)\n                    self.yValues.insert(0,y)\n                    self.xValues.insert(0,x)\n                    self.moveNumber.insert(0,self.count)\n                    self.checkDistance()\n                elif x == 4:\n                    finch.set_turn(RLDir.RIGHT, 180, 50)\n                    self.yValues.insert(0,180)\n                    self.xValues.insert(0,x)\n                    self.moveNumber.insert(0,self.count)\n                    self.checkDistance()\n                self.checkDistance()\n                print(self.xValues)\n                print(self.yValues)\n                self.count += 1\n                if self.count == 20:\n                    o = False\n                    finch.stop_motors()\n                    # basic.show_string(\"Done Exploring,Headed to Start\")\n                    self.returnHomeTWO()\n                    break\n            self.checkDistance()\n    def resultsExplore(self):#Gives the option for the user to print the logs of what movement the finch made on whichever turn\n        for item in self.xValues:#It would be cool to have it where the user could choose which turn they want or to see which movement was most common\n            if item == 1 or item == 5:\n                print(f\"The robot moved foward\")\n            if item == 2:\n                print(\"The robot turned to the right\")\n            if item == 3:\n                print(\"The robot turned to the left\")\n            if item == 4:\n                print(\"The robot turned around\")\n        self.returnHomeTWO()\n    def dance(self):#Makes the robot dance by going back and forth at random angles\n        self.count = 0\n        x = True\n        while x:\n            v = randint(0,100)\n            z = randint(0,100)\n            y = randint(0,100)\n            r = randint(45, 125)\n            finch.set_beak(v, y, z)\n            finch.set_tail(TailPort.ONE, y, z, v)\n            finch.set_tail(TailPort.TWO, z, y, v)\n            finch.set_tail(TailPort.THREE, z, y, v)\n            finch.set_tail(TailPort.FOUR, y, z, v)\n            finch.set_turn(RLDir.RIGHT, 720, 80)\n            finch.set_turn(RLDir.RIGHT, r, 75)\n            finch.set_turn(RLDir.LEFT, r, 75)\n            self.count += 1\n            if self.count == 10:\n                x = False\n                self.selectMode()\n    def lightSelection(self):#how we determine what light colours to use for the robot\n        if finch.get_distance() < 30:\n            finch.set_beak(100, 0, 0) \n        elif finch.get_distance() == 95:\n            finch.set_beak(69, 67, 41)\n            self.dance() \n        elif finch.get_distance() > 30:\n            finch.set_beak(0, 100, 0)\n    def returnHome(self):#V1 doesnt work\n        pass#This method allows the finch to return to its starting loctaion by taking the logged movmets from the exploration phase and reveresing them! \n        #     finch.set_beak(100, 0, 100) first version of return home didnt work too well\n        #     for item in self.xValues[::-1]:\n        #         if item == 1 or item == 5:\n        #             finch.set_move(MoveDir.BACKWARD, self.yValues[-1], 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 2:\n        #             finch.set_turn(RLDir.LEFT, self.yValues[-1], 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 3:\n        #             finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 4:\n        #             finch.set_turn(RLDir.RIGHT, self.yValues[-1], 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 7:\n        #             finch.set_turn(RLDir.RIGHT, 180, 50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         elif item == 8:\n        #             finch.set_move(MoveDir.BACKWARD,35,50)\n        #             self.xValues.pop()\n        #             self.yValues.pop()\n        #         else:\n        #             basic.show_number(1)\n        #         print(self.xValues)\n        #         print(self.yValues)\n        #     self.dance()\n    def returnHomeTWO(self):\n                finch.set_beak(100, 0, 100)\n                while self.xValues:\n                    item = self.xValues[0]\n                    magnitude = self.yValues[0]\n                    if item == 1 or item == 5 or item == 8: \n                        finch.set_move(MoveDir.BACKWARD, magnitude, 50)\n                    elif item == 2: \n                        finch.set_turn(RLDir.LEFT, magnitude, 50)\n                    elif item == 3:\n                        finch.set_turn(RLDir.RIGHT, magnitude, 50)\n                    elif item == 4: \n                        finch.set_turn(RLDir.RIGHT, magnitude, 50)\n                    elif item == 7: \n                        finch.set_turn(RLDir.RIGHT, magnitude, 50)\n                    else:\n                        basic.show_string(\"Done\")\n                        break\n                    self.xValues.pop()\n                    self.yValues.pop()\n                    print(self.xValues) \n                    print(self.yValues)\n                finch.stop_motors()\n                self.dance()\n        \nrobot = SamHenryFinchCode()\nrobot.selectMode()","pxt.json":"{\n    \"name\": \"Finch Project Sam and Henry \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-finch\": \"github:birdbraintechnologies/pxt-finch#v0.0.5\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\",\n    \"languageRestriction\": \"python-only\"\n}\n"}}],"shares":[],"lastSaveTime":1765479461790}